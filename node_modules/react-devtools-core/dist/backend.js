(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReactDevToolsBackend"] = factory();
	else
		root["ReactDevToolsBackend"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 786:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
var __webpack_unused_export__;
/**
 * @license React
 * react-debug-tools.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var ErrorStackParser = __webpack_require__(206),
    React = __webpack_require__(189),
    assign = Object.assign,
    ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),
    hasOwnProperty = Object.prototype.hasOwnProperty,
    hookLog = [],
    primitiveStackCache = null;

function getPrimitiveStackCache() {
  if (null === primitiveStackCache) {
    var cache = new Map();

    try {
      Dispatcher.useContext({
        _currentValue: null
      });
      Dispatcher.useState(null);
      Dispatcher.useReducer(function (s) {
        return s;
      }, null);
      Dispatcher.useRef(null);
      "function" === typeof Dispatcher.useCacheRefresh && Dispatcher.useCacheRefresh();
      Dispatcher.useLayoutEffect(function () {});
      Dispatcher.useInsertionEffect(function () {});
      Dispatcher.useEffect(function () {});
      Dispatcher.useImperativeHandle(void 0, function () {
        return null;
      });
      Dispatcher.useDebugValue(null);
      Dispatcher.useCallback(function () {});
      Dispatcher.useTransition();
      Dispatcher.useSyncExternalStore(function () {
        return function () {};
      }, function () {
        return null;
      }, function () {
        return null;
      });
      Dispatcher.useDeferredValue(null);
      Dispatcher.useMemo(function () {
        return null;
      });
      Dispatcher.useOptimistic(null, function (s) {
        return s;
      });
      Dispatcher.useFormState(function (s) {
        return s;
      }, null);
      Dispatcher.useActionState(function (s) {
        return s;
      }, null);
      Dispatcher.useHostTransitionStatus();
      "function" === typeof Dispatcher.useMemoCache && Dispatcher.useMemoCache(0);

      if ("function" === typeof Dispatcher.use) {
        Dispatcher.use({
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: null
        });
        Dispatcher.use({
          then: function then() {},
          status: "fulfilled",
          value: null
        });

        try {
          Dispatcher.use({
            then: function then() {}
          });
        } catch (x) {}
      }

      Dispatcher.useId();
      "function" === typeof Dispatcher.useResourceEffect && Dispatcher.useResourceEffect(function () {
        return {};
      }, []);
      "function" === typeof Dispatcher.useEffectEvent && Dispatcher.useEffectEvent(function () {});
    } finally {
      var readHookLog = hookLog;
      hookLog = [];
    }

    for (var i = 0; i < readHookLog.length; i++) {
      var hook = readHookLog[i];
      cache.set(hook.primitive, ErrorStackParser.parse(hook.stackError));
    }

    primitiveStackCache = cache;
  }

  return primitiveStackCache;
}

var currentFiber = null,
    currentHook = null,
    currentContextDependency = null;

function nextHook() {
  var hook = currentHook;
  null !== hook && (currentHook = hook.next);
  return hook;
}

function readContext(context) {
  if (null === currentFiber) return context._currentValue;
  if (null === currentContextDependency) throw Error("Context reads do not line up with context dependencies. This is a bug in React Debug Tools.");
  hasOwnProperty.call(currentContextDependency, "memoizedValue") ? (context = currentContextDependency.memoizedValue, currentContextDependency = currentContextDependency.next) : context = context._currentValue;
  return context;
}

var SuspenseException = Error("Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."),
    Dispatcher = {
  use: function use(usable) {
    if (null !== usable && "object" === _typeof(usable)) {
      if ("function" === typeof usable.then) {
        switch (usable.status) {
          case "fulfilled":
            var fulfilledValue = usable.value;
            hookLog.push({
              displayName: null,
              primitive: "Promise",
              stackError: Error(),
              value: fulfilledValue,
              debugInfo: void 0 === usable._debugInfo ? null : usable._debugInfo,
              dispatcherHookName: "Use"
            });
            return fulfilledValue;

          case "rejected":
            throw usable.reason;
        }

        hookLog.push({
          displayName: null,
          primitive: "Unresolved",
          stackError: Error(),
          value: usable,
          debugInfo: void 0 === usable._debugInfo ? null : usable._debugInfo,
          dispatcherHookName: "Use"
        });
        throw SuspenseException;
      }

      if (usable.$$typeof === REACT_CONTEXT_TYPE) return fulfilledValue = readContext(usable), hookLog.push({
        displayName: usable.displayName || "Context",
        primitive: "Context (use)",
        stackError: Error(),
        value: fulfilledValue,
        debugInfo: null,
        dispatcherHookName: "Use"
      }), fulfilledValue;
    }

    throw Error("An unsupported type was passed to use(): " + String(usable));
  },
  readContext: readContext,
  useCacheRefresh: function useCacheRefresh() {
    var hook = nextHook();
    hookLog.push({
      displayName: null,
      primitive: "CacheRefresh",
      stackError: Error(),
      value: null !== hook ? hook.memoizedState : function () {},
      debugInfo: null,
      dispatcherHookName: "CacheRefresh"
    });
    return function () {};
  },
  useCallback: function useCallback(callback) {
    var hook = nextHook();
    hookLog.push({
      displayName: null,
      primitive: "Callback",
      stackError: Error(),
      value: null !== hook ? hook.memoizedState[0] : callback,
      debugInfo: null,
      dispatcherHookName: "Callback"
    });
    return callback;
  },
  useContext: function useContext(context) {
    var value = readContext(context);
    hookLog.push({
      displayName: context.displayName || null,
      primitive: "Context",
      stackError: Error(),
      value: value,
      debugInfo: null,
      dispatcherHookName: "Context"
    });
    return value;
  },
  useEffect: function useEffect(create) {
    nextHook();
    hookLog.push({
      displayName: null,
      primitive: "Effect",
      stackError: Error(),
      value: create,
      debugInfo: null,
      dispatcherHookName: "Effect"
    });
  },
  useImperativeHandle: function useImperativeHandle(ref) {
    nextHook();
    var instance = void 0;
    null !== ref && "object" === _typeof(ref) && (instance = ref.current);
    hookLog.push({
      displayName: null,
      primitive: "ImperativeHandle",
      stackError: Error(),
      value: instance,
      debugInfo: null,
      dispatcherHookName: "ImperativeHandle"
    });
  },
  useDebugValue: function useDebugValue(value, formatterFn) {
    hookLog.push({
      displayName: null,
      primitive: "DebugValue",
      stackError: Error(),
      value: "function" === typeof formatterFn ? formatterFn(value) : value,
      debugInfo: null,
      dispatcherHookName: "DebugValue"
    });
  },
  useLayoutEffect: function useLayoutEffect(create) {
    nextHook();
    hookLog.push({
      displayName: null,
      primitive: "LayoutEffect",
      stackError: Error(),
      value: create,
      debugInfo: null,
      dispatcherHookName: "LayoutEffect"
    });
  },
  useInsertionEffect: function useInsertionEffect(create) {
    nextHook();
    hookLog.push({
      displayName: null,
      primitive: "InsertionEffect",
      stackError: Error(),
      value: create,
      debugInfo: null,
      dispatcherHookName: "InsertionEffect"
    });
  },
  useMemo: function useMemo(nextCreate) {
    var hook = nextHook();
    nextCreate = null !== hook ? hook.memoizedState[0] : nextCreate();
    hookLog.push({
      displayName: null,
      primitive: "Memo",
      stackError: Error(),
      value: nextCreate,
      debugInfo: null,
      dispatcherHookName: "Memo"
    });
    return nextCreate;
  },
  useMemoCache: function useMemoCache(size) {
    var fiber = currentFiber;
    if (null == fiber) return [];
    fiber = null != fiber.updateQueue ? fiber.updateQueue.memoCache : null;
    if (null == fiber) return [];
    var data = fiber.data[fiber.index];

    if (void 0 === data) {
      data = fiber.data[fiber.index] = Array(size);

      for (var i = 0; i < size; i++) {
        data[i] = REACT_MEMO_CACHE_SENTINEL;
      }
    }

    fiber.index++;
    return data;
  },
  useOptimistic: function useOptimistic(passthrough) {
    var hook = nextHook();
    passthrough = null !== hook ? hook.memoizedState : passthrough;
    hookLog.push({
      displayName: null,
      primitive: "Optimistic",
      stackError: Error(),
      value: passthrough,
      debugInfo: null,
      dispatcherHookName: "Optimistic"
    });
    return [passthrough, function () {}];
  },
  useReducer: function useReducer(reducer, initialArg, init) {
    reducer = nextHook();
    initialArg = null !== reducer ? reducer.memoizedState : void 0 !== init ? init(initialArg) : initialArg;
    hookLog.push({
      displayName: null,
      primitive: "Reducer",
      stackError: Error(),
      value: initialArg,
      debugInfo: null,
      dispatcherHookName: "Reducer"
    });
    return [initialArg, function () {}];
  },
  useRef: function useRef(initialValue) {
    var hook = nextHook();
    initialValue = null !== hook ? hook.memoizedState : {
      current: initialValue
    };
    hookLog.push({
      displayName: null,
      primitive: "Ref",
      stackError: Error(),
      value: initialValue.current,
      debugInfo: null,
      dispatcherHookName: "Ref"
    });
    return initialValue;
  },
  useState: function useState(initialState) {
    var hook = nextHook();
    initialState = null !== hook ? hook.memoizedState : "function" === typeof initialState ? initialState() : initialState;
    hookLog.push({
      displayName: null,
      primitive: "State",
      stackError: Error(),
      value: initialState,
      debugInfo: null,
      dispatcherHookName: "State"
    });
    return [initialState, function () {}];
  },
  useTransition: function useTransition() {
    var stateHook = nextHook();
    nextHook();
    stateHook = null !== stateHook ? stateHook.memoizedState : !1;
    hookLog.push({
      displayName: null,
      primitive: "Transition",
      stackError: Error(),
      value: stateHook,
      debugInfo: null,
      dispatcherHookName: "Transition"
    });
    return [stateHook, function () {}];
  },
  useSyncExternalStore: function useSyncExternalStore(subscribe, getSnapshot) {
    nextHook();
    nextHook();
    subscribe = getSnapshot();
    hookLog.push({
      displayName: null,
      primitive: "SyncExternalStore",
      stackError: Error(),
      value: subscribe,
      debugInfo: null,
      dispatcherHookName: "SyncExternalStore"
    });
    return subscribe;
  },
  useDeferredValue: function useDeferredValue(value) {
    var hook = nextHook();
    value = null !== hook ? hook.memoizedState : value;
    hookLog.push({
      displayName: null,
      primitive: "DeferredValue",
      stackError: Error(),
      value: value,
      debugInfo: null,
      dispatcherHookName: "DeferredValue"
    });
    return value;
  },
  useId: function useId() {
    var hook = nextHook();
    hook = null !== hook ? hook.memoizedState : "";
    hookLog.push({
      displayName: null,
      primitive: "Id",
      stackError: Error(),
      value: hook,
      debugInfo: null,
      dispatcherHookName: "Id"
    });
    return hook;
  },
  useFormState: function useFormState(action, initialState) {
    var hook = nextHook();
    nextHook();
    nextHook();
    action = Error();
    var debugInfo = null,
        error = null;
    if (null !== hook) {
      if (initialState = hook.memoizedState, "object" === _typeof(initialState) && null !== initialState && "function" === typeof initialState.then) switch (initialState.status) {
        case "fulfilled":
          var value = initialState.value;
          debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo;
          break;

        case "rejected":
          error = initialState.reason;
          break;

        default:
          error = SuspenseException, debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo, value = initialState;
      } else value = initialState;
    } else value = initialState;
    hookLog.push({
      displayName: null,
      primitive: "FormState",
      stackError: action,
      value: value,
      debugInfo: debugInfo,
      dispatcherHookName: "FormState"
    });
    if (null !== error) throw error;
    return [value, function () {}, !1];
  },
  useActionState: function useActionState(action, initialState) {
    var hook = nextHook();
    nextHook();
    nextHook();
    action = Error();
    var debugInfo = null,
        error = null;
    if (null !== hook) {
      if (initialState = hook.memoizedState, "object" === _typeof(initialState) && null !== initialState && "function" === typeof initialState.then) switch (initialState.status) {
        case "fulfilled":
          var value = initialState.value;
          debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo;
          break;

        case "rejected":
          error = initialState.reason;
          break;

        default:
          error = SuspenseException, debugInfo = void 0 === initialState._debugInfo ? null : initialState._debugInfo, value = initialState;
      } else value = initialState;
    } else value = initialState;
    hookLog.push({
      displayName: null,
      primitive: "ActionState",
      stackError: action,
      value: value,
      debugInfo: debugInfo,
      dispatcherHookName: "ActionState"
    });
    if (null !== error) throw error;
    return [value, function () {}, !1];
  },
  useHostTransitionStatus: function useHostTransitionStatus() {
    var status = readContext({
      _currentValue: null
    });
    hookLog.push({
      displayName: null,
      primitive: "HostTransitionStatus",
      stackError: Error(),
      value: status,
      debugInfo: null,
      dispatcherHookName: "HostTransitionStatus"
    });
    return status;
  },
  useEffectEvent: function useEffectEvent(callback) {
    nextHook();
    hookLog.push({
      displayName: null,
      primitive: "EffectEvent",
      stackError: Error(),
      value: callback,
      debugInfo: null,
      dispatcherHookName: "EffectEvent"
    });
    return callback;
  },
  useResourceEffect: function useResourceEffect(create) {
    nextHook();
    hookLog.push({
      displayName: null,
      primitive: "ResourceEffect",
      stackError: Error(),
      value: create,
      debugInfo: null,
      dispatcherHookName: "ResourceEffect"
    });
  }
},
    DispatcherProxyHandler = {
  get: function get(target, prop) {
    if (target.hasOwnProperty(prop)) return target[prop];
    target = Error("Missing method in Dispatcher: " + prop);
    target.name = "ReactDebugToolsUnsupportedHookError";
    throw target;
  }
},
    DispatcherProxy = "undefined" === typeof Proxy ? Dispatcher : new Proxy(Dispatcher, DispatcherProxyHandler),
    mostLikelyAncestorIndex = 0;

function findSharedIndex(hookStack, rootStack, rootIndex) {
  var source = rootStack[rootIndex].source,
      i = 0;

  a: for (; i < hookStack.length; i++) {
    if (hookStack[i].source === source) {
      for (var a = rootIndex + 1, b = i + 1; a < rootStack.length && b < hookStack.length; a++, b++) {
        if (hookStack[b].source !== rootStack[a].source) continue a;
      }

      return i;
    }
  }

  return -1;
}

function isReactWrapper(functionName, wrapperName) {
  functionName = parseHookName(functionName);
  return "HostTransitionStatus" === wrapperName ? functionName === wrapperName || "FormStatus" === functionName : functionName === wrapperName;
}

function parseHookName(functionName) {
  if (!functionName) return "";
  var startIndex = functionName.lastIndexOf("[as ");
  if (-1 !== startIndex) return parseHookName(functionName.slice(startIndex + 4, -1));
  startIndex = functionName.lastIndexOf(".");
  startIndex = -1 === startIndex ? 0 : startIndex + 1;
  functionName.slice(startIndex).startsWith("unstable_") && (startIndex += 9);
  functionName.slice(startIndex).startsWith("experimental_") && (startIndex += 13);

  if ("use" === functionName.slice(startIndex, startIndex + 3)) {
    if (3 === functionName.length - startIndex) return "Use";
    startIndex += 3;
  }

  return functionName.slice(startIndex);
}

function buildTree(rootStack$jscomp$0, readHookLog) {
  for (var rootChildren = [], prevStack = null, levelChildren = rootChildren, nativeHookID = 0, stackOfChildren = [], i = 0; i < readHookLog.length; i++) {
    var hook = readHookLog[i];
    var rootStack = rootStack$jscomp$0;
    var JSCompiler_inline_result = ErrorStackParser.parse(hook.stackError);

    b: {
      var hookStack = JSCompiler_inline_result,
          rootIndex = findSharedIndex(hookStack, rootStack, mostLikelyAncestorIndex);
      if (-1 !== rootIndex) rootStack = rootIndex;else {
        for (var i$jscomp$0 = 0; i$jscomp$0 < rootStack.length && 5 > i$jscomp$0; i$jscomp$0++) {
          if (rootIndex = findSharedIndex(hookStack, rootStack, i$jscomp$0), -1 !== rootIndex) {
            mostLikelyAncestorIndex = i$jscomp$0;
            rootStack = rootIndex;
            break b;
          }
        }

        rootStack = -1;
      }
    }

    b: {
      hookStack = JSCompiler_inline_result;
      rootIndex = getPrimitiveStackCache().get(hook.primitive);
      if (void 0 !== rootIndex) for (i$jscomp$0 = 0; i$jscomp$0 < rootIndex.length && i$jscomp$0 < hookStack.length; i$jscomp$0++) {
        if (rootIndex[i$jscomp$0].source !== hookStack[i$jscomp$0].source) {
          i$jscomp$0 < hookStack.length - 1 && isReactWrapper(hookStack[i$jscomp$0].functionName, hook.dispatcherHookName) && i$jscomp$0++;
          i$jscomp$0 < hookStack.length - 1 && isReactWrapper(hookStack[i$jscomp$0].functionName, hook.dispatcherHookName) && i$jscomp$0++;
          hookStack = i$jscomp$0;
          break b;
        }
      }
      hookStack = -1;
    }

    JSCompiler_inline_result = -1 === rootStack || -1 === hookStack || 2 > rootStack - hookStack ? -1 === hookStack ? [null, null] : [JSCompiler_inline_result[hookStack - 1], null] : [JSCompiler_inline_result[hookStack - 1], JSCompiler_inline_result.slice(hookStack, rootStack - 1)];
    hookStack = JSCompiler_inline_result[0];
    JSCompiler_inline_result = JSCompiler_inline_result[1];
    rootStack = hook.displayName;
    null === rootStack && null !== hookStack && (rootStack = parseHookName(hookStack.functionName) || parseHookName(hook.dispatcherHookName));

    if (null !== JSCompiler_inline_result) {
      hookStack = 0;

      if (null !== prevStack) {
        for (; hookStack < JSCompiler_inline_result.length && hookStack < prevStack.length && JSCompiler_inline_result[JSCompiler_inline_result.length - hookStack - 1].source === prevStack[prevStack.length - hookStack - 1].source;) {
          hookStack++;
        }

        for (prevStack = prevStack.length - 1; prevStack > hookStack; prevStack--) {
          levelChildren = stackOfChildren.pop();
        }
      }

      for (prevStack = JSCompiler_inline_result.length - hookStack - 1; 1 <= prevStack; prevStack--) {
        hookStack = [], rootIndex = JSCompiler_inline_result[prevStack], rootIndex = {
          id: null,
          isStateEditable: !1,
          name: parseHookName(JSCompiler_inline_result[prevStack - 1].functionName),
          value: void 0,
          subHooks: hookStack,
          debugInfo: null,
          hookSource: {
            lineNumber: rootIndex.lineNumber,
            columnNumber: rootIndex.columnNumber,
            functionName: rootIndex.functionName,
            fileName: rootIndex.fileName
          }
        }, levelChildren.push(rootIndex), stackOfChildren.push(levelChildren), levelChildren = hookStack;
      }

      prevStack = JSCompiler_inline_result;
    }

    hookStack = hook.primitive;
    rootIndex = hook.debugInfo;
    hook = {
      id: "Context" === hookStack || "Context (use)" === hookStack || "DebugValue" === hookStack || "Promise" === hookStack || "Unresolved" === hookStack || "HostTransitionStatus" === hookStack ? null : nativeHookID++,
      isStateEditable: "Reducer" === hookStack || "State" === hookStack,
      name: rootStack || hookStack,
      value: hook.value,
      subHooks: [],
      debugInfo: rootIndex,
      hookSource: null
    };
    rootStack = {
      lineNumber: null,
      functionName: null,
      fileName: null,
      columnNumber: null
    };
    JSCompiler_inline_result && 1 <= JSCompiler_inline_result.length && (JSCompiler_inline_result = JSCompiler_inline_result[0], rootStack.lineNumber = JSCompiler_inline_result.lineNumber, rootStack.functionName = JSCompiler_inline_result.functionName, rootStack.fileName = JSCompiler_inline_result.fileName, rootStack.columnNumber = JSCompiler_inline_result.columnNumber);
    hook.hookSource = rootStack;
    levelChildren.push(hook);
  }

  processDebugValues(rootChildren, null);
  return rootChildren;
}

function processDebugValues(hooksTree, parentHooksNode) {
  for (var debugValueHooksNodes = [], i = 0; i < hooksTree.length; i++) {
    var hooksNode = hooksTree[i];
    "DebugValue" === hooksNode.name && 0 === hooksNode.subHooks.length ? (hooksTree.splice(i, 1), i--, debugValueHooksNodes.push(hooksNode)) : processDebugValues(hooksNode.subHooks, hooksNode);
  }

  null !== parentHooksNode && (1 === debugValueHooksNodes.length ? parentHooksNode.value = debugValueHooksNodes[0].value : 1 < debugValueHooksNodes.length && (parentHooksNode.value = debugValueHooksNodes.map(function (_ref) {
    return _ref.value;
  })));
}

function handleRenderFunctionError(error) {
  if (error !== SuspenseException) {
    if (error instanceof Error && "ReactDebugToolsUnsupportedHookError" === error.name) throw error;
    var wrapperError = Error("Error rendering inspected component", {
      cause: error
    });
    wrapperError.name = "ReactDebugToolsRenderError";
    wrapperError.cause = error;
    throw wrapperError;
  }
}

function inspectHooks(renderFunction, props, currentDispatcher) {
  null == currentDispatcher && (currentDispatcher = ReactSharedInternals);
  var previousDispatcher = currentDispatcher.H;
  currentDispatcher.H = DispatcherProxy;

  try {
    var ancestorStackError = Error();
    renderFunction(props);
  } catch (error) {
    handleRenderFunctionError(error);
  } finally {
    renderFunction = hookLog, hookLog = [], currentDispatcher.H = previousDispatcher;
  }

  currentDispatcher = ErrorStackParser.parse(ancestorStackError);
  return buildTree(currentDispatcher, renderFunction);
}

function restoreContexts(contextMap) {
  contextMap.forEach(function (value, context) {
    return context._currentValue = value;
  });
}

__webpack_unused_export__ = inspectHooks;

exports.inspectHooksOfFiber = function (fiber, currentDispatcher) {
  null == currentDispatcher && (currentDispatcher = ReactSharedInternals);
  if (0 !== fiber.tag && 15 !== fiber.tag && 11 !== fiber.tag) throw Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
  getPrimitiveStackCache();
  currentHook = fiber.memoizedState;
  currentFiber = fiber;

  if (hasOwnProperty.call(currentFiber, "dependencies")) {
    var dependencies = currentFiber.dependencies;
    currentContextDependency = null !== dependencies ? dependencies.firstContext : null;
  } else if (hasOwnProperty.call(currentFiber, "dependencies_old")) dependencies = currentFiber.dependencies_old, currentContextDependency = null !== dependencies ? dependencies.firstContext : null;else if (hasOwnProperty.call(currentFiber, "dependencies_new")) dependencies = currentFiber.dependencies_new, currentContextDependency = null !== dependencies ? dependencies.firstContext : null;else if (hasOwnProperty.call(currentFiber, "contextDependencies")) dependencies = currentFiber.contextDependencies, currentContextDependency = null !== dependencies ? dependencies.first : null;else throw Error("Unsupported React version. This is a bug in React Debug Tools.");

  dependencies = fiber.type;
  var props = fiber.memoizedProps;

  if (dependencies !== fiber.elementType && dependencies && dependencies.defaultProps) {
    props = assign({}, props);
    var defaultProps = dependencies.defaultProps;

    for (propName in defaultProps) {
      void 0 === props[propName] && (props[propName] = defaultProps[propName]);
    }
  }

  var propName = new Map();

  try {
    if (null !== currentContextDependency && !hasOwnProperty.call(currentContextDependency, "memoizedValue")) for (defaultProps = fiber; defaultProps;) {
      if (10 === defaultProps.tag) {
        var context = defaultProps.type;
        void 0 !== context._context && (context = context._context);
        propName.has(context) || (propName.set(context, context._currentValue), context._currentValue = defaultProps.memoizedProps.value);
      }

      defaultProps = defaultProps.return;
    }

    if (11 === fiber.tag) {
      var renderFunction = dependencies.render;
      context = props;
      var ref = fiber.ref;
      fiber = currentDispatcher;
      var previousDispatcher = fiber.H;
      fiber.H = DispatcherProxy;

      try {
        var ancestorStackError = Error();
        renderFunction(context, ref);
      } catch (error) {
        handleRenderFunctionError(error);
      } finally {
        var readHookLog = hookLog;
        hookLog = [];
        fiber.H = previousDispatcher;
      }

      var rootStack = ErrorStackParser.parse(ancestorStackError);
      return buildTree(rootStack, readHookLog);
    }

    return inspectHooks(dependencies, props, currentDispatcher);
  } finally {
    currentContextDependency = currentHook = currentFiber = null, restoreContexts(propName);
  }
};

/***/ }),

/***/ 987:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(786);
} else {}

/***/ }),

/***/ 126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(169);
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),
    REACT_PORTAL_TYPE = Symbol.for("react.portal"),
    REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),
    REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),
    REACT_PROFILER_TYPE = Symbol.for("react.profiler"),
    REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),
    REACT_CONTEXT_TYPE = Symbol.for("react.context"),
    REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),
    REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),
    REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),
    REACT_MEMO_TYPE = Symbol.for("react.memo"),
    REACT_LAZY_TYPE = Symbol.for("react.lazy"),
    REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"),
    REACT_POSTPONE_TYPE = Symbol.for("react.postpone"),
    REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"),
    MAYBE_ITERATOR_SYMBOL = Symbol.iterator;

function getIteratorFn(maybeIterable) {
  if (null === maybeIterable || "object" !== _typeof(maybeIterable)) return null;
  maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
  return "function" === typeof maybeIterable ? maybeIterable : null;
}

var ReactNoopUpdateQueue = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueForceUpdate: function enqueueForceUpdate() {},
  enqueueReplaceState: function enqueueReplaceState() {},
  enqueueSetState: function enqueueSetState() {}
},
    assign = Object.assign,
    emptyObject = {};

function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};

Component.prototype.setState = function (partialState, callback) {
  if ("object" !== _typeof(partialState) && "function" !== typeof partialState && null != partialState) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, partialState, callback, "setState");
};

Component.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
};

function ComponentDummy() {}

ComponentDummy.prototype = Component.prototype;

function PureComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
pureComponentPrototype.constructor = PureComponent;
assign(pureComponentPrototype, Component.prototype);
pureComponentPrototype.isPureReactComponent = !0;
var isArrayImpl = Array.isArray,
    ReactSharedInternals = {
  H: null,
  A: null,
  T: null,
  S: null,
  V: null
},
    hasOwnProperty = Object.prototype.hasOwnProperty;

function ReactElement(type, key, self, source, owner, props) {
  self = props.ref;
  return {
    $$typeof: REACT_ELEMENT_TYPE,
    type: type,
    key: key,
    ref: void 0 !== self ? self : null,
    props: props
  };
}

function cloneAndReplaceKey(oldElement, newKey) {
  return ReactElement(oldElement.type, newKey, void 0, void 0, void 0, oldElement.props);
}

function isValidElement(object) {
  return "object" === _typeof(object) && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
}

function escape(key) {
  var escaperLookup = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + key.replace(/[=:]/g, function (match) {
    return escaperLookup[match];
  });
}

var userProvidedKeyEscapeRegex = /\/+/g;

function getElementKey(element, index) {
  return "object" === _typeof(element) && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
}

function noop$1() {}

function resolveThenable(thenable) {
  switch (thenable.status) {
    case "fulfilled":
      return thenable.value;

    case "rejected":
      throw thenable.reason;

    default:
      switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(function (fulfilledValue) {
        "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
      }, function (error) {
        "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
      })), thenable.status) {
        case "fulfilled":
          return thenable.value;

        case "rejected":
          throw thenable.reason;
      }

  }

  throw thenable;
}

function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
  var type = _typeof(children);

  if ("undefined" === type || "boolean" === type) children = null;
  var invokeCallback = !1;
  if (null === children) invokeCallback = !0;else switch (type) {
    case "bigint":
    case "string":
    case "number":
      invokeCallback = !0;
      break;

    case "object":
      switch (children.$$typeof) {
        case REACT_ELEMENT_TYPE:
        case REACT_PORTAL_TYPE:
          invokeCallback = !0;
          break;

        case REACT_LAZY_TYPE:
          return invokeCallback = children._init, mapIntoArray(invokeCallback(children._payload), array, escapedPrefix, nameSoFar, callback);
      }

  }
  if (invokeCallback) return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function (c) {
    return c;
  })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(callback, escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(userProvidedKeyEscapeRegex, "$&/") + "/") + invokeCallback)), array.push(callback)), 1;
  invokeCallback = 0;
  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
  if (isArrayImpl(children)) for (var i = 0; i < children.length; i++) {
    nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
  } else if (i = getIteratorFn(children), "function" === typeof i) for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done;) {
    nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(nameSoFar, array, escapedPrefix, type, callback);
  } else if ("object" === type) {
    if ("function" === typeof children.then) return mapIntoArray(resolveThenable(children), array, escapedPrefix, nameSoFar, callback);
    array = String(children);
    throw Error("Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead.");
  }
  return invokeCallback;
}

function mapChildren(children, func, context) {
  if (null == children) return children;
  var result = [],
      count = 0;
  mapIntoArray(children, result, "", "", function (child) {
    return func.call(context, child, count++);
  });
  return result;
}

function lazyInitializer(payload) {
  if (-1 === payload._status) {
    var ctor = payload._result;
    ctor = ctor();
    ctor.then(function (moduleObject) {
      if (0 === payload._status || -1 === payload._status) payload._status = 1, payload._result = moduleObject;
    }, function (error) {
      if (0 === payload._status || -1 === payload._status) payload._status = 2, payload._result = error;
    });
    -1 === payload._status && (payload._status = 0, payload._result = ctor);
  }

  if (1 === payload._status) return payload._result.default;
  throw payload._result;
}

function useOptimistic(passthrough, reducer) {
  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
}

var reportGlobalError = "function" === typeof reportError ? reportError : function (error) {
  if ("object" === (typeof window === "undefined" ? "undefined" : _typeof(window)) && "function" === typeof window.ErrorEvent) {
    var event = new window.ErrorEvent("error", {
      bubbles: !0,
      cancelable: !0,
      message: "object" === _typeof(error) && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
      error: error
    });
    if (!window.dispatchEvent(event)) return;
  } else if ("object" === (typeof process === "undefined" ? "undefined" : _typeof(process)) && "function" === typeof process.emit) {
    process.emit("uncaughtException", error);
    return;
  }

  console.error(error);
};

function noop() {}

exports.Children = {
  map: mapChildren,
  forEach: function forEach(children, forEachFunc, forEachContext) {
    mapChildren(children, function () {
      forEachFunc.apply(this, arguments);
    }, forEachContext);
  },
  count: function count(children) {
    var n = 0;
    mapChildren(children, function () {
      n++;
    });
    return n;
  },
  toArray: function toArray(children) {
    return mapChildren(children, function (child) {
      return child;
    }) || [];
  },
  only: function only(children) {
    if (!isValidElement(children)) throw Error("React.Children.only expected to receive a single React element child.");
    return children;
  }
};
exports.Component = Component;
exports.Fragment = REACT_FRAGMENT_TYPE;
exports.Profiler = REACT_PROFILER_TYPE;
exports.PureComponent = PureComponent;
exports.StrictMode = REACT_STRICT_MODE_TYPE;
exports.Suspense = REACT_SUSPENSE_TYPE;
exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
exports.__COMPILER_RUNTIME = {
  __proto__: null,
  c: function c(size) {
    return ReactSharedInternals.H.useMemoCache(size);
  }
};

exports.act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};

exports.cache = function (fn) {
  return function () {
    return fn.apply(null, arguments);
  };
};

exports.captureOwnerStack = function () {
  return null;
};

exports.cloneElement = function (element, config, children) {
  if (null === element || void 0 === element) throw Error("The argument must be a React element, but you passed " + element + ".");
  var props = assign({}, element.props),
      key = element.key,
      owner = void 0;
  if (null != config) for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config) {
    !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
  }
  var propName = arguments.length - 2;
  if (1 === propName) props.children = children;else if (1 < propName) {
    for (var childArray = Array(propName), i = 0; i < propName; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }
  return ReactElement(element.type, key, void 0, void 0, owner, props);
};

exports.createContext = function (defaultValue) {
  defaultValue = {
    $$typeof: REACT_CONTEXT_TYPE,
    _currentValue: defaultValue,
    _currentValue2: defaultValue,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  defaultValue.Provider = defaultValue;
  defaultValue.Consumer = {
    $$typeof: REACT_CONSUMER_TYPE,
    _context: defaultValue
  };
  return defaultValue;
};

exports.createElement = function (type, config, children) {
  var propName,
      props = {},
      key = null;
  if (null != config) for (propName in void 0 !== config.key && (key = "" + config.key), config) {
    hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
  }
  var childrenLength = arguments.length - 2;
  if (1 === childrenLength) props.children = children;else if (1 < childrenLength) {
    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }

    props.children = childArray;
  }
  if (type && type.defaultProps) for (propName in childrenLength = type.defaultProps, childrenLength) {
    void 0 === props[propName] && (props[propName] = childrenLength[propName]);
  }
  return ReactElement(type, key, void 0, void 0, null, props);
};

exports.createRef = function () {
  return {
    current: null
  };
};

exports.experimental_useEffectEvent = function (callback) {
  return ReactSharedInternals.H.useEffectEvent(callback);
};

exports.experimental_useOptimistic = function (passthrough, reducer) {
  return useOptimistic(passthrough, reducer);
};

exports.experimental_useResourceEffect = void 0;

exports.forwardRef = function (render) {
  return {
    $$typeof: REACT_FORWARD_REF_TYPE,
    render: render
  };
};

exports.isValidElement = isValidElement;

exports.lazy = function (ctor) {
  return {
    $$typeof: REACT_LAZY_TYPE,
    _payload: {
      _status: -1,
      _result: ctor
    },
    _init: lazyInitializer
  };
};

exports.memo = function (type, compare) {
  return {
    $$typeof: REACT_MEMO_TYPE,
    type: type,
    compare: void 0 === compare ? null : compare
  };
};

exports.startTransition = function (scope) {
  var prevTransition = ReactSharedInternals.T,
      currentTransition = {};
  ReactSharedInternals.T = currentTransition;

  try {
    var returnValue = scope(),
        onStartTransitionFinish = ReactSharedInternals.S;
    null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
    "object" === _typeof(returnValue) && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
  } catch (error) {
    reportGlobalError(error);
  } finally {
    ReactSharedInternals.T = prevTransition;
  }
};

exports.unstable_Activity = REACT_OFFSCREEN_TYPE;
exports.unstable_SuspenseList = REACT_SUSPENSE_LIST_TYPE;
exports.unstable_ViewTransition = REACT_VIEW_TRANSITION_TYPE;

exports.unstable_addTransitionType = function (type) {
  var pendingTransitionTypes = ReactSharedInternals.V;
  null === pendingTransitionTypes ? ReactSharedInternals.V = [type] : -1 === pendingTransitionTypes.indexOf(type) && pendingTransitionTypes.push(type);
};

exports.unstable_getCacheForType = function (resourceType) {
  var dispatcher = ReactSharedInternals.A;
  return dispatcher ? dispatcher.getCacheForType(resourceType) : resourceType();
};

exports.unstable_postpone = function (reason) {
  reason = Error(reason);
  reason.$$typeof = REACT_POSTPONE_TYPE;
  throw reason;
};

exports.unstable_useCacheRefresh = function () {
  return ReactSharedInternals.H.useCacheRefresh();
};

exports.use = function (usable) {
  return ReactSharedInternals.H.use(usable);
};

exports.useActionState = function (action, initialState, permalink) {
  return ReactSharedInternals.H.useActionState(action, initialState, permalink);
};

exports.useCallback = function (callback, deps) {
  return ReactSharedInternals.H.useCallback(callback, deps);
};

exports.useContext = function (Context) {
  return ReactSharedInternals.H.useContext(Context);
};

exports.useDebugValue = function () {};

exports.useDeferredValue = function (value, initialValue) {
  return ReactSharedInternals.H.useDeferredValue(value, initialValue);
};

exports.useEffect = function (create, deps) {
  return ReactSharedInternals.H.useEffect(create, deps);
};

exports.useId = function () {
  return ReactSharedInternals.H.useId();
};

exports.useImperativeHandle = function (ref, create, deps) {
  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
};

exports.useInsertionEffect = function (create, deps) {
  return ReactSharedInternals.H.useInsertionEffect(create, deps);
};

exports.useLayoutEffect = function (create, deps) {
  return ReactSharedInternals.H.useLayoutEffect(create, deps);
};

exports.useMemo = function (create, deps) {
  return ReactSharedInternals.H.useMemo(create, deps);
};

exports.useOptimistic = useOptimistic;

exports.useReducer = function (reducer, initialArg, init) {
  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
};

exports.useRef = function (initialValue) {
  return ReactSharedInternals.H.useRef(initialValue);
};

exports.useState = function (initialState) {
  return ReactSharedInternals.H.useState(initialState);
};

exports.useSyncExternalStore = function (subscribe, getSnapshot, getServerSnapshot) {
  return ReactSharedInternals.H.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
};

exports.useTransition = function () {
  return ReactSharedInternals.H.useTransition();
};

exports.version = "19.1.0-experimental-44c3d3d6-20250207";

/***/ }),

/***/ 189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(126);
} else {}

/***/ }),

/***/ 206:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(430)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function ErrorStackParser(StackFrame) {
  'use strict';

  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    /**
     * Given an Error object, extract the most information from it.
     *
     * @param {Error} error object
     * @return {Array} of StackFrames
     */
    parse: function ErrorStackParser$$parse(error) {
      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
        return this.parseOpera(error);
      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error);
      } else if (error.stack) {
        return this.parseFFOrSafari(error);
      } else {
        throw new Error('Cannot parse given Error object');
      }
    },
    // Separate line and column num